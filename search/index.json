[{"content":"page48\n$$ T(n) = 2T(\\lfloor x/2 \\rfloor)+2\n$$ 推定其解的形式也是 $$ T(n)=\\Omicron(nlgn) $$ 验证： 先假设存在一个小正整数m\u0026lt; n成立 (解释：这里即为数学归纳法的n=0或者n=1，这里的思路是根据假设来验证后续大于m的情况下猜想也成立) 则对于$ m=\\lfloor n/2 \\rfloor $ 有 $$ T(\\lfloor n/2 \\rfloor)\\leq c(\\lfloor n/2 \\rfloor)lg(\\lfloor n/2 \\rfloor)\\ \\dots\\ \\dots $$ 对后续情况验证后，回头证明开始的边界条件下（即m时确实成立）\n","date":"2024-11-25T23:29:49+08:00","permalink":"https://cristigina.github.io/p/algorithm-introduction-notes/","title":"Algorithm Introduction Notes"},{"content":"Mybatis 属性配置 1 2 3 4 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/mybatis spring.datasource.username=root //用户名 spring.datasource.password=1234 //密码 用数据库时配置与数据相同的工具类\n编写SQL数据 1 2 3 4 5 @Mapper public interface UserMapper { @Select(\u0026#34;select * from user\u0026#34;) //数据库语句 public List\u0026lt;User\u0026gt; list(); } JDBC Java语言操作关系型数据库的一套API，相比Mybatis的整合明显更繁琐\n数据库连接池 数据库连接池是个容器，负责分配、管理数据库连接(Connection) 它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个 释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏\n优势 资源重用 提升系统响应速度 避免数据库连接遗漏\n用Druid连接池的配置\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在application文件内 设置同Mybatis属性\nlombok 注释\n用于简化工具类的声明，自动内置getter，setter，tostring等方法\n注释类 说明 @Data 提供了更综合的生成代码功能（@Getter + @Setter + @ToString + @EqualsAndHashCode） @NoArgsConstructor 为实体类生成无参的构造器方法 @AllArgsConstructor 为实体类生成除了static修饰的字段之外带有各参数的构造器方法。 Mybatis详解 入门 lombok MySQL Driver Mybatis Framework 1 2 3 4 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/mybatis spring.datasource.username=root spring.datasource.password=1234 对数据库内对应数据类创建同样结构的工具类，放在pojo文件夹内\n删除 mysql语句\n1 delete from emp where id = 17; 接口方法\n1 2 @Delete(\u0026#34;delete from emp where id = #{id}\u0026#34;) public void delete(Integer id); 如果mapper接口方法形参只有一个普通类型的参数，#{…} 里面的属性名可以随便写，如：#{id}、#{value}。\n1 2 #指定mybatis输出日志的位置,输出控制台 mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 预编译sql优点 性能更高 更安全(防止SQL注入)\n新增 1 insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) values (\u0026#39;songyuanqiao\u0026#39;,\u0026#39;宋远桥\u0026#39;,1,\u0026#39;1.jpg\u0026#39;,2,\u0026#39;2012-10-09\u0026#39;,2,\u0026#39;2022-10-01 10:00:00\u0026#39;,\u0026#39;2022-10-01 10:00:00\u0026#39;); 接口方法\n1 2 3 @Insert(\u0026#34;insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) \u0026#34; + \u0026#34;values(#{username}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime})\u0026#34;) public void insert(Emp emp); 新增(主键返回) 在数据添加成功后，需要获取插入数据库数据的主键。如：添加套餐数据时，还需要维护套餐菜品关系表数据。\n1 2 3 4 @Options(keyProperty = \u0026#34;id\u0026#34;, useGeneratedKeys = true) @Insert(\u0026#34;insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) \u0026#34; + \u0026#34;values(#{username}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime})\u0026#34;) public void insert(Emp emp); 会自动将生成的主键值，赋值给emp对象的id属性\n更改 sql语句\n1 update emp set username = \u0026#39;songdaxia\u0026#39;, name = \u0026#39;宋大侠\u0026#39;, gender = 1 , image = \u0026#39;1.jpg\u0026#39; , job = 2, entrydate = \u0026#39;2012-01-01\u0026#39;, dept_id = 2, update_time = \u0026#39;2022-10-01 12:12:12\u0026#39; where id = 19; 接口方法\n1 2 3 4 5 6 7 8 9 10 @Update(\u0026#34;update emp set username=#{username}, name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entrydate}, dept_id=#{deptId}, update_time=#{updateTime} where id=#{id}\u0026#34;) public void update(Emp emp); 查找 sql语句\n1 select * from emp where id = 19; 接口方法\n1 2 @Select(\u0026#34;select * from emp where id = #{id}\u0026#34;) public Emp getById(Integer id); 实体类属性名 和 数据库表查询返回的字段名一致，mybatis会自动封装。 如果实体类属性名 和 数据库表查询返回的字段名不一致，不能自动封装。\n别名 1 2 @Select(\u0026#34;select id, username, password, name, gender, image, job, entrydate, dept_id deptId, create_time createTime, update_time updateTime from emp where id = #{id} \u0026#34;) //dept_id deptId 第一个是数据库内名字，第二个是类内属性名 public Emp getById(Integer id); 映射（Result和Results） 1 2 3 4 5 6 @Select(\u0026#34;select * from emp where id = #{id}\u0026#34;) @Results({ @Result(column = \u0026#34;dept_id\u0026#34;, property = \u0026#34;deptId\u0026#34;), @Result(column = \u0026#34;create_time\u0026#34;, property = \u0026#34;createTime\u0026#34;), @Result(column = \u0026#34;update_time\u0026#34;, property = \u0026#34;updateTime\u0026#34;)}) public Emp getById(Integer id); 驼峰命名则自动映射（属性设置） 如果字段名与属性名符合驼峰命名规则，mybatis会自动通过驼峰命名规则映射。 1 2 #开启驼峰命名自动映射，即从数据库字段名 a_column 映射到Java 属性名 aColumn。 mybatis.configuration.map-underscore-to-camel-case=true 条件查找 sql语句\n1 select * from emp where name like \u0026#39;%张%\u0026#39; and gender = 1 and entrydate between \u0026#39;2010-01-01\u0026#39; and \u0026#39;2020-01-01 \u0026#39; order by update_time desc; 接口方法\n用$ 有内存注入风险 1 2 @Select(\u0026#34;select * from emp where name like \u0026#39;%${name}%\u0026#39; and gender = #{gender} and entrydate between #{begin} and #{end} order by update_time desc\u0026#34;) public List\u0026lt;Emp\u0026gt; list(String name, Short gender , LocalDate begin , LocalDate end); 用# 安全 1 2 @Select(\u0026#34;select * from emp where name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) and gender = #{gender} and entrydate between #{begin} and #{end} order by update_time desc\u0026#34;) public List\u0026lt;Emp\u0026gt; list(String name, Short gender , LocalDate begin , LocalDate end); XML映射文件 XML文件的名称与Mapper接口名称一致，并且放置在相同包下（同包同名）。 XML文件的namespace属性为Mapper接口全限定名一致。 XML文件中sql语句的id与Mapper 接口中的方法名一致。 动态sql \u0026hellip;\n","date":"2024-11-14T15:20:45+08:00","permalink":"https://cristigina.github.io/p/javaweb-quickstart02/","title":"Javaweb Quickstart02"},{"content":"请求 简单请求 1 2 3 4 5 6 7 8 @RequestMapping(\u0026#34;/test\u0026#34;) public String test(HttpServletRequest request){ String name = request.getParam(\u0026#34;name\u0026#34;); String ageStr = request.getParam(\u0026#34;age\u0026#34;); Integer age = Integer.parseInt(ageStr); ... return \u0026#34;OK!\u0026#34; } 简单参数：参数名与形参变量名相同，定义形参即可接收参数 会自动进行类型转换\n1 2 3 4 5 6 @RequestMapping(\u0026#34;/test\u0026#34;) public String test(String name, Integer age){ ... return \u0026#34;OK!\u0026#34; } 方法形参名称与请求参数名称不匹配，可以使用 @RequestParam 完成映射\n第一个name是@RequestParam属性，第二个\u0026quot;name\u0026quot;是request请求体内参数名\n1 2 3 4 5 6 @RequestMapping(\u0026#34;/test\u0026#34;) public String test(@RequestParam(name = \u0026#34;name\u0026#34;) String username , Integer age){ ... return \u0026#34;OK!\u0026#34; } 实体参数 简单实体对象：请求参数名与形参对象属性名相同，定义POJO接收即可\n1 2 3 4 5 @RequestMapping(\u0026#34;/simplePojo\u0026#34;) public String simplePojo(User user){ System.out.println(user); return \u0026#34;OK\u0026#34;; } 1 2 3 4 public class User { private String name; private Integer age; } 复杂实体对象：请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套POJO属性参数。\n请求参数名与形参对象属性名相同，即可直接通过POJO接收\n数组/集合 数组：请求参数名与形参中数组变量名相同，可以直接使用数组封装 集合：请求参数名与形参中集合变量名相同，通过@RequestParam绑定参数关系\n日期 Pass\nJSON JSON数据键名与形参对象属性名相同，定义POJO类型形参即可接收参数，需要使用 @RequestBody 标识\n1 2 3 4 5 @RequestMapping(\u0026#34;/jsonParam\u0026#34;) public String jsonParam(@RequestBody User user){ System.out.println(user); return \u0026#34;OK\u0026#34;; } 路径 通过请求URL直接传递参数，使用{…}来标识该路径参数，需要使用 @PathVariable 获取路径参数\n例： postman请求\nGET http://localhost:8080/path/1 1 2 3 4 5 @RequestMapping(\u0026#34;/path/{id}\u0026#34;) public String pathParam(@PathVariable Integer id){ System.out.println(id); return \u0026#34;OK\u0026#34;; } GET http://localhost:8080/path/1/Tom 1 2 3 4 5 @RequestMapping(\u0026#34;/path/{id}/{name}\u0026#34;) public String pathParam2(@PathVariable Integer id, @PathVariable String name){ System.out.println(id+ \u0026#34; : \u0026#34; +name); return \u0026#34;OK\u0026#34;; } 响应 @ResponseBody\n类型：方法注解、类注解 位置：Controller方法上/类上 作用：将方法返回值直接响应，如果返回值类型是 实体对象/集合 ，将会转换为JSON格式响应 说明：@RestController = @Controller + @ResponseBody ; 统一相应结果 分层解耦 三层架构 Controller Service Dao(Data Access Object)\n分层解耦 内聚：软件中各个功能模块内部的功能联系。 耦合：衡量软件中各个层/模块之间的依赖、关联的程度。 软件设计原则：高内聚低耦合。 用到依赖注入 和 控制反转\n控制反转： Inversion Of Control，简称IOC。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。 依赖注入： Dependency Injection，简称DI。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。 Bean对象：IOC容器中创建、管理的对象，称之为bean。\nIOC\u0026amp;DI入门 Service层 及 Dao层的实现类，交给IOC容器管理。\n用到@Component\n为Controller及Service注入运行时，依赖的对象。\n用到@Autowired\nIOC详解 @Controller 标注在控制器类上\n@Service 标注在业务类上\n注解，要想生效，还需要被组件扫描注解@ComponentScan扫描。\n@ComponentScan注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解 @SpringBootApplication 中，默认扫描的范围是启动类所在包及其子包。\nDI详解 @Autowired注解，默认是按照类型进行，如果存在多个相同类型的bean，报错\n解决：\n1 2 3 4 5 6 7 8 9 @Primary @Service public class EmpServiceA implements EmpService { ... } ... @Autowired @Qualifier(\u0026#34;empServiceA\u0026#34;) private EmpService empService ; ","date":"2024-11-13T23:49:40+08:00","permalink":"https://cristigina.github.io/p/javaweb-quickstart-01/","title":"Javaweb Quickstart 01"},{"content":"简单概念，指令 1 2 vue create vue-app-name npm run serve 1 2 3 4 5 6 7 8 9 10 data(){ return { example : \u0026#39;stirng text\u0026#39; } }, method : { demo() { } } ","date":"2024-11-13T16:08:33+08:00","permalink":"https://cristigina.github.io/p/vue-%E9%80%9F%E9%80%9A/","title":"Vue 速通"},{"content":"高温高压的制冷剂蒸汽在进入冷凝器后分为三个阶段，对应三个区域：过热区，两相区，过冷区。\n第一个阶段：气态的制冷剂通过对流换热向管壁放热，管外翅片的空气通过对流换热从管壁上吸热，为简化计算，此阶段假设管内外压降均为0，管内蒸汽温度不断降低吗，直到达到饱和温度。\n第二阶段：管内制冷剂处于气液两相混合的状态，通过释放潜热在恒温恒压的状态下与管外翅片区域的空气进行换热，直到蒸汽完全消失，制冷剂变为饱和液态。\n第三阶段：液态制冷剂在湍流下与管外空气进行换热，直到离开冷凝器。\n翅片管式换热器的对流换热系数分为管内制冷剂区域和管外空气区域两部分。管内外均需要通过流体的普朗特数计算得到对流换热系数， $Pr$ 通过公式(1)计算得到：翅片管式换热器的对流换热系数分为管内制冷剂区域和管外空气区域两部分。管内外均需要通过流体的普朗特数计算得到对流换热系数， $Pr$ 通过公式(1)计算得到：\n管内对流换热分析 过热区 此阶段制冷剂为过饱和蒸汽， 纯液体换热特点描述。\n","date":"2024-11-13T13:08:25+08:00","permalink":"https://cristigina.github.io/p/%E5%AF%B9%E6%B5%81%E6%8D%A2%E7%83%AD%E7%B3%BB%E6%95%B0/","title":"对流换热系数"},{"content":"前后端联调\n不设置axios跨域代理信息时会报错CORS\n在vue.config.js内加入以下设置：\n1 2 3 4 5 6 7 8 proxy: { \u0026#39;/api\u0026#39;: { target: \u0026#39;http://localhost:3000\u0026#39;, //后端端口号，在application.properties里设置的端口号 changeOrigin: true, pathRewrite: { \u0026#39;^/api\u0026#39;: \u0026#39;\u0026#39; } //此时axios请求的链接，例如\u0026#34;/api/test\u0026#34;，会被直接转发到localhost:3000/test } } ","date":"2024-11-12T23:59:21+08:00","permalink":"https://cristigina.github.io/p/vue%E8%B7%A8%E5%9F%9F%E8%AE%BE%E7%BD%AE/","title":"vue跨域设置"},{"content":"正文测试 中文文本测试：图片导入逻辑\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://cristigina.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu8709503783197716240.jpg","permalink":"https://cristigina.github.io/p/test-chinese/","title":"中文插入图片消失"}]